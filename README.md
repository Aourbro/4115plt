# Advance Calculator (COMS 4115 PLT)

## **Project Overview**

The first deliverable implements a **lexical analyzer (Tokenizer)** using a **Finite State Machine (FSM)** to process input strings or files. The tokenizer identifies **tokens** such as numbers, symbols, and keywords, handling errors for illegal characters and unrecognized symbols. The primary goal is to parse input systematically by breaking it down into meaningful tokens and reporting any parsing issues.

## Teammates
Yunhao Xing (yx2812)  
Ziang Xu (zx2462) 

## Installation

### Environment Preparation (Developed on `Ubuntu 24.04`)
install g++ and make: `sudo apt install g++ make`

### 'Install' from source
run make: `make` or `make main`  
You can run `make clean` to clean up the build files.

### Usage
```
Usage: ./main [options]
Options:
  --help                 Display this information.
  -s <string>            Take the <string> as input LaTeX expression.
  -f <file>              Take content in the <file> as input.
  -o <file>              Place the output into <file>.
Option -f has higher priority than -s
```

## Running Test Cases
Test cases are available in the `./testcases` directory, named `test{n}.tex`.  
To run a test: `./main -f ./testcases/test0.tex`

### test cases details:
  -  `./testcases/test0.tex`: a valid one
  -  `./testcases/test1.tex`: empty string error
  -  `./testcases/test2.tex`: bad symbols error
  -  `./testcases/test3.tex`: digit after letter error
  -  `./testcases/test4.tex`: a nested valid one

#### Sample output from test0
```
total 14 tokens:
  <Escape Character, \>
  <Keyword, frac>
  <Left Brace, {>
  <Number, 1>
  <Right Brace, }>
  <Left Brace, {>
  <Number, 10>
  <Right Brace, }>
  <Symbol, a>
  <Escape Character, \>
  <Symbol, alpha>
  <Operator, +>
  <Escape Character, \>
  <Symbol, beta>
``` 

#### Sample output from test1
```
Error: Empty String
total 0 tokens:
```

#### Sample output from test2
```
Bad Symbols:
  bad at position 1
Error: Bad Symbol
total 8 tokens:
  <Escape Character, \>
  <Operator, +>
  <Symbol, s>
  <Symbol, y>
  <Symbol, m>
  <Symbol, b>
  <Symbol, o>
  <Symbol, l>
```

#### Sample output from test3
```
Error: Digit After Letter at position 12: '2'
total 6 tokens:
  <Symbol, a>
  <Escape Character, \>
  <Symbol, zeta>
  <Number, 1>
  <Operator, +>
  <Symbol, b>
```

#### Sample output from test4
```
total 17 tokens:
  <Escape Character, \>
  <Keyword, frac>
  <Left Brace, {>
  <Number, 2>
  <Operator, +>
  <Escape Character, \>
  <Keyword, frac>
  <Left Brace, {>
  <Number, 1>
  <Right Brace, }>
  <Left Brace, {>
  <Number, 2>
  <Right Brace, }>
  <Right Brace, }>
  <Left Brace, {>
  <Number, 3>
  <Right Brace, }>
```


## Lexical Grammar
Symbol := [a-z]|alpha|beta|...|zeta  
Number := [0-9]+  
Keyword := frac  
Operator := \\+|\\-|\\*|/|%  
EscapeChar := \\\  
LeftParenthesis := \\(  
RightParenthesis := \\)  
LeftBrace := \\{  
RightBrace := \\}  

## How the Lexer Works
### **Features**
1. **Tokenization of Strings and Files:** 
   - Supports both string inputs and file-based tokenization.
2. **Finite State Machine (FSM):** 
   - Uses a state-transition table to manage parsing logic.
3. **Error Handling:** 
   - Detects illegal characters and logs unrecognized symbols.
4. **Token Classification:** 
   - Distinguishes between numbers, keywords, and symbols.
5. **Detailed Token Output:** 
   - Outputs token streams and error reports for easier debugging.


### **Core Concepts**
#### **1. Tokenization Process**
- The lexer reads input **character by character**.
- Each character triggers **state transitions** based on its type (e.g., number, symbol, keyword).
- **Actions** are executed based on the new state, including:
  - Adding characters to tokens
  - Pushing tokens to the token stream
  - Handling errors for illegal characters

#### **2. State Transitions and Actions**
The core logic for state transitions is implemented in `readChar()`. 
##### Summary of the actions:
- **`DoNothing`**: Skip the character.
- **`AddToken`**: Add the character to the current token.
- **`PushToken`**: Push the current token to the stream and reset it.
- **`PushThis`**: Push the current character as a separate token.
- **`ErrorHandle`**: Handle and report parsing errors.


## Parser
The parser component (parser.cpp) takes the token stream generated by the lexer and builds an Abstract Syntax Tree (AST). It includes various parsing functions, each handling specific grammar rules for expressions, terms, factors, symbols, and numbers.

The parser leverages the following classes from the AST definitions in AST.h:

- **`ExprAST`**: Represents expressions, with handling for terms and operators.
- **`ExprsAST`**: Manages sequences of expressions, handling multiple operators (e.g., + and -).
- **`TermAST`**: Represents individual terms, breaking down into expressions and term sequences.
- **`TermsAST`**: Manages sequences of terms, specifically for multiplication and division operators.
- **`FactAST`**: Handles individual factors, including parentheses and symbols.
- **`NumAST`**: Manages numbers and handles cases where a keyword represents a numeric expression.
- **`SymbsAST`**: Represents symbols and manages nested sequences of symbols.
- **`Symb0AST`**: Parses symbols with trailing operator tokens.
- **`FracAST`**: Parses fractional expressions, handling numerators and denominators separately.
Each AST node class contains a `Dump` method for structured output, useful for debugging and analyzing the AST structure.

## Abstract Syntax Tree (AST)
The AST is a tree-like representation of the structure and operations in the code. Each node in the tree corresponds to a construct in the source code.

### Sample output from test0:
```
ExprAST
  TermAST
    UExprAST
      FactAST
        NumAST
          FracAST
            \frac
            {
            ExprAST
              TermAST
                UExprAST
                  FactAST
                    NumAST
                      number(1)
            }
            {
            ExprAST
              TermAST
                UExprAST
                  FactAST
                    NumAST
                      number(10)
            }
        Symb0AST
          SymbsAST
            symbol(a)
            Symb0AST
              SymbsAST
                symbol(\alpha)
  ExprsAST
    +
    TermAST
      UExprAST
        FactAST
          SymbsAST
            symbol(\beta)
```

### Sample output from test1:
Error: Empty String

### Sample output from test2:
Bad Symbols:
  \bad at position 0
Error: Bad Symbol

### Sample output from test3:
Error: Digit After Letter at position 12: '2'
total 5 tokens:
  <Symbol, a>
  <Symbol, \zeta>
  <Number, 1>
  <Operator, +>
  <Symbol, b>
Unexpected token "1" at token 2
### Sample output from test4:
```
ExprAST
  TermAST
    UExprAST
      FactAST
        NumAST
          FracAST
            \frac
            {
            ExprAST
              TermAST
                UExprAST
                  FactAST
                    NumAST
                      number(2)
              ExprsAST
                +
                TermAST
                  UExprAST
                    FactAST
                      NumAST
                        FracAST
                          \frac
                          {
                          ExprAST
                            TermAST
                              UExprAST
                                FactAST
                                  NumAST
                                    number(1)
                          }
                          {
                          ExprAST
                            TermAST
                              UExprAST
                                FactAST
                                  NumAST
                                    number(2)
                          }
            }
            {
            ExprAST
              TermAST
                UExprAST
                  FactAST
                    NumAST
                      number(3)
            }
```